
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/00_getting_started/01_example_within-subject-classification-riemannian.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_00_getting_started_01_example_within-subject-classification-riemannian.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_00_getting_started_01_example_within-subject-classification-riemannian.py:


Example 01: Within-subject classification with Riemannian classifier
====================================================================

This example demonstrates a **within-subject motor imagery classification**
pipeline using a **Riemannian geometry-based classifier** with ``rosoku``.

We use the **Dreyer2023** dataset and evaluate classification performance on a
single subject, where training and test sets are defined by different recording
runs of the same subject.

The example highlights a *classical EEG decoding pipeline* and serves as a
baseline reference for comparison with deep-learning-based approaches.

Key aspects illustrated in this example include:

- Callback-based loading and preprocessing of raw EEG data using MNE
- Conversion of epoched EEG signals into **SPD covariance matrices**
- Use of a Riemannian classifier implemented via **pyRiemann**
- Simple and transparent experimental design with minimal hyperparameters

The pipeline consists of the following steps:

1. Load and band-pass filter raw EEG recordings
2. Epoch the continuous data and extract EEG channels
3. Estimate covariance matrices from epoched signals
4. Train and evaluate a Riemannian classifier on subject-specific runs
5. Collect performance metrics and per-trial predictions

This example is intentionally kept minimal and interpretable, and can be used
as a starting point or a baseline for more advanced EEG decoding pipelines
implemented with ``rosoku``.

.. GENERATED FROM PYTHON SOURCE LINES 34-39

.. code-block:: Python


    # Authors: Simon Kojima <simon.kojima@inria.fr>
    #
    # License: BSD (3-clause)








.. GENERATED FROM PYTHON SOURCE LINES 40-42

Import Packages
===============

.. GENERATED FROM PYTHON SOURCE LINES 42-51

.. code-block:: Python

    import functools
    from pathlib import Path
    import mne
    import pyriemann
    import rosoku

    from moabb.datasets import Dreyer2023









.. GENERATED FROM PYTHON SOURCE LINES 52-54

Define callback functions
=========================

.. GENERATED FROM PYTHON SOURCE LINES 54-109

.. code-block:: Python



    def callback_load_epochs(
        items, split, dataset, l_freq, h_freq, order_filter, tmin, tmax
    ):
        subject = items[0]
        keywords = items[1:]

        sessions = dataset.get_data(subjects=[subject])
        raws_dict = sessions[subject]["0"]

        epochs_list = []

        for name_run, raw in raws_dict.items():
            if not True in [k in name_run for k in keywords]:
                continue

            raw.filter(
                l_freq=l_freq,
                h_freq=h_freq,
                method="iir",
                iir_params={"ftype": "butter", "order": order_filter, "btype": "bandpass"},
            )

            raw = raw.pick(picks="eeg")

            epochs = mne.Epochs(
                raw=raw,
                tmin=tmin,
                tmax=tmax,
                baseline=None,
            )

            epochs_list.append(epochs)

        return mne.concatenate_epochs(epochs_list)


    def callback_proc_epochs(epochs, split):
        # do nothing in this example
        return epochs


    def callback_convert_epochs_to_ndarray(
        epochs,
        split,
        label_keys,
    ):
        X = epochs.get_data()
        X = pyriemann.estimation.Covariances(estimator="lwf").transform(X)
        y = rosoku.utils.get_labels_from_epochs(epochs, label_keys)

        return X, y









.. GENERATED FROM PYTHON SOURCE LINES 110-112

Run the Experiment
==================

.. GENERATED FROM PYTHON SOURCE LINES 112-141

.. code-block:: Python


    subject = 10

    dataset = Dreyer2023()
    label_keys = {"left_hand": 0, "right_hand": 1}

    save_base = Path("~").expanduser() / "rosoku-log"

    results = rosoku.conventional(
        items_train=[subject, "R1", "R2"],
        items_test=[[subject, "R3", "R4", "R5", "R6"]],
        callback_load_epochs=functools.partial(
            callback_load_epochs,
            dataset=dataset,
            l_freq=8.0,
            h_freq=30.0,
            order_filter=4,
            tmin=dataset.interval[0] + 0.5,
            tmax=dataset.interval[1],
        ),
        callback_proc_epochs=callback_proc_epochs,
        callback_convert_epochs_to_ndarray=functools.partial(
            callback_convert_epochs_to_ndarray, label_keys=label_keys
        ),
        scoring=["accuracy", "f1"],
        samples_fname=save_base / "samples.parquet",
        additional_values={"subject": subject},
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    0it [00:00, ?it/s]    9it [00:00, 12516.16it/s]
    Reading 0 ... 230911  =      0.000 ...   450.998 secs...
    Reading 0 ... 230911  =      0.000 ...   450.998 secs...
    Reading 0 ... 230911  =      0.000 ...   450.998 secs...
    Reading 0 ... 230911  =      0.000 ...   450.998 secs...
    Reading 0 ... 230911  =      0.000 ...   450.998 secs...
    Reading 0 ... 230911  =      0.000 ...   450.998 secs...
    Filtering raw data in 1 contiguous segment
    Setting up band-pass filter from 8 - 30 Hz

    IIR filter parameters
    ---------------------
    Butterworth bandpass zero-phase (two-pass forward and reverse) non-causal filter:
    - Filter order 16 (effective, after forward-backward)
    - Cutoffs at 8.00, 30.00 Hz: -6.02, -6.02 dB

    Used Annotations descriptions: [np.str_('left_hand'), np.str_('right_hand')]
    Ignoring annotation durations and creating fixed-duration epochs around annotation onsets.
    Not setting metadata
    40 matching events found
    No baseline correction applied
    0 projection items activated
    Filtering raw data in 1 contiguous segment
    Setting up band-pass filter from 8 - 30 Hz

    IIR filter parameters
    ---------------------
    Butterworth bandpass zero-phase (two-pass forward and reverse) non-causal filter:
    - Filter order 16 (effective, after forward-backward)
    - Cutoffs at 8.00, 30.00 Hz: -6.02, -6.02 dB

    Used Annotations descriptions: [np.str_('left_hand'), np.str_('right_hand')]
    Ignoring annotation durations and creating fixed-duration epochs around annotation onsets.
    Not setting metadata
    40 matching events found
    No baseline correction applied
    0 projection items activated
    /home/skojima/git/rosoku/examples/00_getting_started/01_example_within-subject-classification-riemannian.py:89: RuntimeWarning: Concatenation of Annotations within Epochs is not supported yet. All annotations will be dropped.
      return mne.concatenate_epochs(epochs_list)
    Using data from preloaded Raw for 40 events and 2305 original time points ...
    0 bad epochs dropped
    Using data from preloaded Raw for 40 events and 2305 original time points ...
    0 bad epochs dropped
    Using data from preloaded Raw for 40 events and 2305 original time points ...
    Using data from preloaded Raw for 40 events and 2305 original time points ...
    Not setting metadata
    80 matching events found
    No baseline correction applied
    0it [00:00, ?it/s]    9it [00:00, 21632.51it/s]
    Reading 0 ... 230911  =      0.000 ...   450.998 secs...
    Reading 0 ... 230911  =      0.000 ...   450.998 secs...
    Reading 0 ... 230911  =      0.000 ...   450.998 secs...
    Reading 0 ... 230911  =      0.000 ...   450.998 secs...
    Reading 0 ... 230911  =      0.000 ...   450.998 secs...
    Reading 0 ... 230911  =      0.000 ...   450.998 secs...
    Filtering raw data in 1 contiguous segment
    Setting up band-pass filter from 8 - 30 Hz

    IIR filter parameters
    ---------------------
    Butterworth bandpass zero-phase (two-pass forward and reverse) non-causal filter:
    - Filter order 16 (effective, after forward-backward)
    - Cutoffs at 8.00, 30.00 Hz: -6.02, -6.02 dB

    Used Annotations descriptions: [np.str_('left_hand'), np.str_('right_hand')]
    Ignoring annotation durations and creating fixed-duration epochs around annotation onsets.
    Not setting metadata
    40 matching events found
    No baseline correction applied
    0 projection items activated
    Filtering raw data in 1 contiguous segment
    Setting up band-pass filter from 8 - 30 Hz

    IIR filter parameters
    ---------------------
    Butterworth bandpass zero-phase (two-pass forward and reverse) non-causal filter:
    - Filter order 16 (effective, after forward-backward)
    - Cutoffs at 8.00, 30.00 Hz: -6.02, -6.02 dB

    Used Annotations descriptions: [np.str_('left_hand'), np.str_('right_hand')]
    Ignoring annotation durations and creating fixed-duration epochs around annotation onsets.
    Not setting metadata
    40 matching events found
    No baseline correction applied
    0 projection items activated
    Filtering raw data in 1 contiguous segment
    Setting up band-pass filter from 8 - 30 Hz

    IIR filter parameters
    ---------------------
    Butterworth bandpass zero-phase (two-pass forward and reverse) non-causal filter:
    - Filter order 16 (effective, after forward-backward)
    - Cutoffs at 8.00, 30.00 Hz: -6.02, -6.02 dB

    Used Annotations descriptions: [np.str_('left_hand'), np.str_('right_hand')]
    Ignoring annotation durations and creating fixed-duration epochs around annotation onsets.
    Not setting metadata
    40 matching events found
    No baseline correction applied
    0 projection items activated
    Filtering raw data in 1 contiguous segment
    Setting up band-pass filter from 8 - 30 Hz

    IIR filter parameters
    ---------------------
    Butterworth bandpass zero-phase (two-pass forward and reverse) non-causal filter:
    - Filter order 16 (effective, after forward-backward)
    - Cutoffs at 8.00, 30.00 Hz: -6.02, -6.02 dB

    Used Annotations descriptions: [np.str_('left_hand'), np.str_('right_hand')]
    Ignoring annotation durations and creating fixed-duration epochs around annotation onsets.
    Not setting metadata
    40 matching events found
    No baseline correction applied
    0 projection items activated
    /home/skojima/git/rosoku/examples/00_getting_started/01_example_within-subject-classification-riemannian.py:89: RuntimeWarning: Concatenation of Annotations within Epochs is not supported yet. All annotations will be dropped.
      return mne.concatenate_epochs(epochs_list)
    Using data from preloaded Raw for 40 events and 2305 original time points ...
    0 bad epochs dropped
    Using data from preloaded Raw for 40 events and 2305 original time points ...
    0 bad epochs dropped
    Using data from preloaded Raw for 40 events and 2305 original time points ...
    0 bad epochs dropped
    Using data from preloaded Raw for 40 events and 2305 original time points ...
    0 bad epochs dropped
    Using data from preloaded Raw for 40 events and 2305 original time points ...
    Using data from preloaded Raw for 40 events and 2305 original time points ...
    Using data from preloaded Raw for 40 events and 2305 original time points ...
    Using data from preloaded Raw for 40 events and 2305 original time points ...
    Not setting metadata
    160 matching events found
    No baseline correction applied




.. GENERATED FROM PYTHON SOURCE LINES 142-144

Print Results
=============

.. GENERATED FROM PYTHON SOURCE LINES 144-145

.. code-block:: Python

    print(results.to_string())




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

            items_train                    items_test    classifier  accuracy        f1  subject
    0  [10, "R1", "R2"]  [10, "R3", "R4", "R5", "R6"]  TSClassifier   0.85625  0.862275       10
    1  [10, "R1", "R2"]  [10, "R3", "R4", "R5", "R6"]           MDM   0.84375  0.853801       10





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 2.902 seconds)


.. _sphx_glr_download_auto_examples_00_getting_started_01_example_within-subject-classification-riemannian.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 01_example_within-subject-classification-riemannian.ipynb <01_example_within-subject-classification-riemannian.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 01_example_within-subject-classification-riemannian.py <01_example_within-subject-classification-riemannian.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: 01_example_within-subject-classification-riemannian.zip <01_example_within-subject-classification-riemannian.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
